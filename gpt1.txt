//
//  OTPAppDelegate.swift
//  Authenticator
//
//  Copyright (c) 2013-2023 Authenticator authors
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

import UIKit
import OneTimePassword
import SVProgressHUD

@UIApplicationMain
class OTPAppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow? = UIWindow(frame: UIScreen.main.bounds)

    let app = AppController()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        let fontAttributes = [NSAttributedString.Key.font: UIFont.otpBarButtonFont]
        UIBarButtonItem.appearance().setTitleTextAttributes(fontAttributes, for: .normal)
        UIBarButtonItem.appearance().setTitleTextAttributes(fontAttributes, for: .highlighted)

        let disabledAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.otpBarButtonFont,
            .foregroundColor: UIColor.otpBarForegroundColor.withAlphaComponent(0.3),
        ]
        UIBarButtonItem.appearance().setTitleTextAttributes(disabledAttributes, for: .disabled)

        // Restore white-on-black style
        SVProgressHUD.setForegroundColor(.otpLightColor)
        SVProgressHUD.setBackgroundColor(UIColor(white: 0, alpha: 0.95))
        SVProgressHUD.setMinimumDismissTimeInterval(1)

        self.window?.rootViewController = app.rootViewController
        self.window?.makeKeyAndVisible()

        return true
    }

    func applicationWillEnterForeground(_ application: UIApplication) {
        // Ensure the UI is updated with the latest view model whenever the app returns from the background.
        app.updateView()
    }

    func application(_ application: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -> Bool {
        if let token = try? Token(url: url) {
            let message = "Do you want to add a token for “\(token.name)”?"

            let alert = UIAlertController(title: "Add Token", message: message, preferredStyle: .alert)

            let acceptHandler: (UIAlertAction) -> Void = { [weak app] (_) in
                app?.addTokenFromURL(token)
            }

            alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
            alert.addAction(UIAlertAction(title: "OK", style: .default, handler: acceptHandler))

            // TODO: Fix the confirmation alert presentation when a modal is open.
            window?.rootViewController?.present(alert, animated: true)

            return true
        }

        return false
    }
}
//
//  RootViewController.swift
//  dor1an2FA (formerly Authenticator)
//
//  Based on Authenticator, Copyright (c) 2015-2019 Authenticator authors
//  Modified and renamed to dor1an2FA by ch4r1i3b in 2024
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//
import UIKit

private let otpTitleTextAttributes: [NSAttributedString.Key: Any] = [
    .foregroundColor: UIColor.otpBarForegroundColor,
    .font: UIFont.otpBarTitleFont,
]

let otpBarButtonTextAttributes: [NSAttributedString.Key: Any] = [
    .foregroundColor: UIColor.otpBarForegroundColor,
    .font: UIFont.otpBarButtonFont,
]

extension UINavigationBarAppearance {
    static let appDefault: UINavigationBarAppearance = {
        let appearance = UINavigationBarAppearance()

        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = .otpBarBackgroundColor

        appearance.titleTextAttributes = otpTitleTextAttributes
        appearance.largeTitleTextAttributes = otpTitleTextAttributes

        appearance.buttonAppearance.normal.titleTextAttributes = otpBarButtonTextAttributes
        appearance.backButtonAppearance.normal.titleTextAttributes = otpBarButtonTextAttributes
        appearance.doneButtonAppearance.normal.titleTextAttributes = otpBarButtonTextAttributes

        return appearance
    }()
}

extension UINavigationBar {
    func applyAppStyle() {
        standardAppearance = .appDefault
        compactAppearance = .appDefault
        scrollEdgeAppearance = .appDefault
        if #available(iOS 15, *) {
            compactScrollEdgeAppearance = .appDefault
        }
    }
}

class OpaqueNavigationController: UINavigationController {
    override func viewDidLoad() {
        super.viewDidLoad()

        navigationBar.barStyle = .black
        navigationBar.isTranslucent = false
        navigationBar.barTintColor = UIColor.otpBarBackgroundColor
        navigationBar.tintColor = UIColor.otpBarForegroundColor
        navigationBar.titleTextAttributes = otpTitleTextAttributes
        navigationBar.applyAppStyle()
    }

    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
}

class RootViewController: OpaqueNavigationController {
    private var currentViewModel: Root.ViewModel

    private var tokenListViewController: TokenListViewController
    private var modalNavController: UINavigationController?

    private let dispatchAction: (Root.Action) -> Void

    init(viewModel: Root.ViewModel, dispatchAction: @escaping (Root.Action) -> Void) {
        self.currentViewModel = viewModel
        self.dispatchAction = dispatchAction
        tokenListViewController = TokenListViewController(
            viewModel: viewModel.tokenList,
            dispatchAction: compose(Root.Action.tokenListAction, dispatchAction)
        )

        super.init(nibName: nil, bundle: nil)
        self.viewControllers = [tokenListViewController]
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private func presentViewControllers(_ viewControllersToPresent: [UIViewController]) {
        guard let navController = modalNavController else {
            let navController = OpaqueNavigationController()
            navController.modalPresentationStyle = .fullScreen
            navController.delegate = self
            navController.setViewControllers(viewControllersToPresent, animated: false)
            present(navController, animated: true)
            modalNavController = navController
            return
        }
        guard navController.viewControllers != viewControllersToPresent else {
            return
        }
        navController.setViewControllers(viewControllersToPresent, animated: true)
    }

    private func dismissViewController() {
        if modalNavController != nil {
            modalNavController = nil
            dismiss(animated: true)
        }
    }
}

protocol ModelBased {
    associatedtype ViewModel
    associatedtype Action

    init(viewModel: ViewModel, dispatchAction: @escaping (Action) -> Void)
    func update(with viewModel: ViewModel)
}

typealias ModelBasedViewController = UIViewController & ModelBased

extension TokenScannerViewController: ModelBased {}
extension TokenFormViewController: ModelBased {}
extension InfoListViewController: ModelBased {}
extension InfoViewController: ModelBased {}
extension DisplayOptionsViewController: ModelBased {}

private func reify<ViewController: ModelBasedViewController>(_ existingViewController: UIViewController?, viewModel: ViewController.ViewModel, dispatchAction: @escaping (ViewController.Action) -> Void) -> ViewController {
    if let viewController = existingViewController as? ViewController {
        viewController.update(with: viewModel)
        return viewController
    } else {
        let viewController = ViewController(viewModel: viewModel, dispatchAction: dispatchAction)
        return viewController
    }
}

extension RootViewController {
    func update(with viewModel: Root.ViewModel) {
        tokenListViewController.update(with: viewModel.tokenList)

        switch viewModel.modal {
        case .none:
            dismissViewController()

        case .scanner(let scannerViewModel):
            presentViewModel(scannerViewModel, using: TokenScannerViewController.self, actionTransform: Root.Action.tokenScannerAction)

        case .entryForm(let formViewModel):
            presentViewModel(formViewModel, using: TokenFormViewController.self, actionTransform: Root.Action.tokenEntryFormAction)

        case .editForm(let formViewModel):
            presentViewModel(formViewModel, using: TokenFormViewController.self, actionTransform: Root.Action.tokenEditFormAction)

        case let .menu(menuViewModel):
            switch menuViewModel.child {
            case .info(let infoViewModel):
                presentViewModels(menuViewModel.infoList, using: InfoListViewController.self, actionTransform: compose(Menu.Action.infoListEffect, Root.Action.menuAction), and: infoViewModel, using: InfoViewController.self, actionTransform: compose(Menu.Action.infoEffect, Root.Action.menuAction))

            case .displayOptions(let displayOptionsViewModel):
                presentViewModels(menuViewModel.infoList, using: InfoListViewController.self, actionTransform: compose(Menu.Action.infoListEffect, Root.Action.menuAction), and: displayOptionsViewModel, using: DisplayOptionsViewController.self, actionTransform: compose(Menu.Action.displayOptionsEffect, Root.Action.menuAction))

            case .none:
                presentViewModel(menuViewModel.infoList, using: InfoListViewController.self, actionTransform: compose(Menu.Action.infoListEffect, Root.Action.menuAction))
            }
        }
        currentViewModel = viewModel
    }

    private func presentViewModel<ViewController: ModelBasedViewController>(_ viewModel: ViewController.ViewModel, using _: ViewController.Type, actionTransform: @escaping ((ViewController.Action) -> Root.Action)) {
        let viewController: ViewController = reify(modalNavController?.topViewController, viewModel: viewModel, dispatchAction: compose(actionTransform, dispatchAction))
        presentViewControllers([viewController])
    }

    private func presentViewModels<A: ModelBasedViewController, B: ModelBasedViewController>(_ viewModelA: A.ViewModel, using _: A.Type, actionTransform actionTransformA: @escaping ((A.Action) -> Root.Action), and viewModelB: B.ViewModel, using _: B.Type, actionTransform actionTransformB: @escaping ((B.Action) -> Root.Action)) {
        let viewControllerA: A = reify(modalNavController?.viewControllers.first, viewModel: viewModelA, dispatchAction: compose(actionTransformA, dispatchAction))
        let viewControllerB: B = reify(modalNavController?.topViewController, viewModel: viewModelB, dispatchAction: compose(actionTransformB, dispatchAction))
        presentViewControllers([viewControllerA, viewControllerB])
    }
}

private func compose<A, B, C>(_ transform: @escaping (A) -> B, _ handler: @escaping (B) -> C) -> (A) -> C {
    return { handler(transform($0)) }
}

extension RootViewController: UINavigationControllerDelegate {
    func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
        if case .menu(let menu) = currentViewModel.modal, viewController is InfoListViewController {
            switch menu.child {
            case .info:
                dispatchAction(.menuAction(.dismissInfo))
            case .displayOptions:
                dispatchAction(.menuAction(.dismissDisplayOptions))
            default:
                break
            }
        }
    }
}
//
//  Root.swift
//  Authenticator
//
//  Copyright (c) 2015-2019 Authenticator authors
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

import Foundation
import OneTimePassword

struct Root: Component {
    private var tokenList: TokenList
    private var modal: Modal
    private let deviceCanScan: Bool

    // swiftlint:disable:next strict_fileprivate
    fileprivate enum Modal {
        case none
        case scanner(TokenScanner)
        case entryForm(TokenEntryForm)
        case editForm(TokenEditForm)
        case menu(Menu)

        func viewModel(digitGroupSize: Int) -> RootViewModel.ModalViewModel {
            switch self {
            case .none:
                return .none
            case .scanner(let scanner):
                return .scanner(scanner.viewModel)
            case .entryForm(let form):
                return .entryForm(form.viewModel)
            case .editForm(let form):
                return .editForm(form.viewModel)
            case let .menu(menu):
                return .menu(menu.viewModel(digitGroupSize: digitGroupSize))
            }
        }
    }

    init(deviceCanScan: Bool) {
        tokenList = TokenList()
        modal = .none
        self.deviceCanScan = deviceCanScan
    }
}

// MARK: View

extension Root {
    typealias ViewModel = RootViewModel

    func viewModel(with persistentTokens: [PersistentToken], at displayTime: DisplayTime, digitGroupSize: Int) -> (viewModel: ViewModel, nextRefreshTime: Date) {
        let (tokenListViewModel, nextRefreshTime) = tokenList.viewModel(
            with: persistentTokens,
            at: displayTime,
            digitGroupSize: digitGroupSize
        )
        let viewModel = ViewModel(
            tokenList: tokenListViewModel,
            modal: modal.viewModel(digitGroupSize: digitGroupSize)
        )
        return (viewModel: viewModel, nextRefreshTime: nextRefreshTime)
    }
}

// MARK: Update

extension Root {
    enum Action {
        case tokenListAction(TokenList.Action)
        case tokenEntryFormAction(TokenEntryForm.Action)
        case tokenEditFormAction(TokenEditForm.Action)
        case tokenScannerAction(TokenScanner.Action)
        case menuAction(Menu.Action)

        case addTokenFromURL(Token)
    }

    enum Event {
        case addTokenFromURLSucceeded
        case tokenFormSucceeded

        case addTokenFailed(Error)
        case saveTokenFailed(Error)
        case updateTokenFailed(Error)
        case moveTokenFailed(Error)
        case deleteTokenFailed(Error)
    }

    enum Effect {
        case addToken(Token,
            success: Event,
            failure: (Error) -> Event)

        case saveToken(Token, PersistentToken,
            success: Event,
            failure: (Error) -> Event)

        case updatePersistentToken(PersistentToken,
            failure: (Error) -> Event)

        case moveToken(fromIndex: Int, toIndex: Int,
            failure: (Error) -> Event)

        case deletePersistentToken(PersistentToken,
            failure: (Error) -> Event)

        case showErrorMessage(String)
        case showSuccessMessage(String)
        case showApplicationSettings
        case openURL(URL)
        case setDigitGroupSize(Int)
    }

    mutating func update(with action: Action) throws -> Effect? {
        do {
            switch action {
            case .tokenListAction(let action):
                let effect = tokenList.update(with: action)
                return effect.flatMap { effect in
                    handleTokenListEffect(effect)
                }

            case .tokenEntryFormAction(let action):
                let effect = try modal.withEntryForm({ form in form.update(with: action) })
                return effect.flatMap { effect in
                    handleTokenEntryFormEffect(effect)
                }

            case .tokenEditFormAction(let action):
                let effect = try modal.withEditForm({ form in form.update(with: action) })
                return effect.flatMap { effect in
                    handleTokenEditFormEffect(effect)
                }

            case .tokenScannerAction(let action):
                let effect = try modal.withScanner({ scanner in scanner.update(with: action) })
                return effect.flatMap { effect in
                    handleTokenScannerEffect(effect)
                }

            case .menuAction(let action):
                let effect = try modal.withMenu({ menu in try menu.update(with: action) })
                return effect.flatMap { effect in
                    handleMenuEffect(effect)
                }

            case .addTokenFromURL(let token):
                return .addToken(token,
                                 success: Event.addTokenFromURLSucceeded,
                                 failure: Event.addTokenFailed)
            }
        } catch {
            throw ComponentError(underlyingError: error, action: action, component: self)
        }
    }

    mutating func update(with event: Event) -> Effect? {
        switch event {
        case .addTokenFromURLSucceeded:
            return nil

        case .tokenFormSucceeded:
            // Dismiss the modal form.
            modal = .none
            return nil

        case .addTokenFailed:
            return .showErrorMessage("Failed to add token.")
        case .saveTokenFailed:
            return .showErrorMessage("Failed to save token.")
        case .updateTokenFailed:
            return .showErrorMessage("Failed to update token.")
        case .moveTokenFailed:
            return .showErrorMessage("Failed to move token.")
        case .deleteTokenFailed:
            return .showErrorMessage("Failed to delete token.")
        }
    }

    private mutating func handleTokenListEffect(_ effect: TokenList.Effect) -> Effect? {
        switch effect {
        case .beginTokenEntry:
            if deviceCanScan {
                modal = .scanner(TokenScanner())
            } else {
                modal = .entryForm(TokenEntryForm())
            }
            return nil

        case .beginTokenEdit(let persistentToken):
            let form = TokenEditForm(persistentToken: persistentToken)
            modal = .editForm(form)
            return nil

        case let .updateToken(persistentToken):
            return .updatePersistentToken(persistentToken,
                                          failure: Event.updateTokenFailed)

        case let .moveToken(fromIndex, toIndex):
            return .moveToken(fromIndex: fromIndex, toIndex: toIndex,
                              failure: Event.moveTokenFailed)

        case let .deletePersistentToken(persistentToken):
            return .deletePersistentToken(persistentToken,
                                          failure: Event.deleteTokenFailed)

        case .showErrorMessage(let message):
            return .showErrorMessage(message)

        case .showSuccessMessage(let message):
            return .showSuccessMessage(message)

        case .showBackupInfo:
            do {
                modal = .menu(Menu(info: try Info.backupInfo()))
                return nil
            } catch {
                return .showErrorMessage("Failed to load backup info.")
            }

        case .showInfo:
            modal = .menu(Menu())
            return nil
        }
    }

    private mutating func handleTokenEntryFormEffect(_ effect: TokenEntryForm.Effect) -> Effect? {
        switch effect {
        case .cancel:
            modal = .none
            return nil

        case .saveNewToken(let token):
            return .addToken(token,
                             success: Event.tokenFormSucceeded,
                             failure: Event.addTokenFailed)

        case .showErrorMessage(let message):
            return .showErrorMessage(message)
        }
    }

    private mutating func handleTokenEditFormEffect(_ effect: TokenEditForm.Effect) -> Effect? {
        switch effect {
        case .cancel:
            modal = .none
            return nil

        case let .saveChanges(token, persistentToken):
            return .saveToken(token, persistentToken,
                              success: Event.tokenFormSucceeded,
                              failure: Event.saveTokenFailed)

        case .showErrorMessage(let message):
            return .showErrorMessage(message)
        }
    }

    private mutating func handleTokenScannerEffect(_ effect: TokenScanner.Effect) -> Effect? {
        switch effect {
        case .cancel:
            modal = .none
            return nil

        case .beginManualTokenEntry:
            if CommandLine.isDemo {
                // If this is a demo, show the pre-filled demo form.
                modal = .entryForm(TokenEntryForm.demoForm)
                return nil
            }

            modal = .entryForm(TokenEntryForm())
            return nil

        case .showApplicationSettings:
            return .showApplicationSettings

        case .saveNewToken(let token):
            return .addToken(token,
                             success: Event.tokenFormSucceeded,
                             failure: Event.addTokenFailed)

        case .showErrorMessage(let message):
            return .showErrorMessage(message)
        }
    }

    private mutating func handleMenuEffect(_ effect: Menu.Effect) -> Effect? {
        switch effect {
        case .dismissMenu:
            modal = .none
            return nil

        case let .showErrorMessage(message):
            return .showErrorMessage(message)

        case let .showSuccessMessage(message):
            return .showSuccessMessage(message)

        case let .openURL(url):
            return .openURL(url)

        case let .setDigitGroupSize(digitGroupSize):
            return .setDigitGroupSize(digitGroupSize)
        }
    }
}

private extension Root.Modal {
    struct Error: Swift.Error {
        let expectedType: Any.Type
        let actualState: Root.Modal
    }

    mutating func withEntryForm<ResultType>(_ body: (inout TokenEntryForm) -> ResultType) throws -> ResultType {
        guard case .entryForm(var form) = self else {
            throw Error(expectedType: TokenEntryForm.self, actualState: self)
        }
        let result = body(&form)
        self = .entryForm(form)
        return result
    }

    mutating func withEditForm<ResultType>(_ body: (inout TokenEditForm) -> ResultType) throws -> ResultType {
        guard case .editForm(var form) = self else {
            throw Error(expectedType: TokenEditForm.self, actualState: self)
        }
        let result = body(&form)
        self = .editForm(form)
        return result
    }

    mutating func withScanner<ResultType>(_ body: (inout TokenScanner) -> ResultType) throws -> ResultType {
        guard case .scanner(var scanner) = self else {
            throw Error(expectedType: TokenScanner.self, actualState: self)
        }
        let result = body(&scanner)
        self = .scanner(scanner)
        return result
    }

    mutating func withMenu<ResultType>(_ body: (inout Menu) throws -> ResultType) throws -> ResultType {
        guard case .menu(var menu) = self else {
            throw Error(expectedType: Menu.self, actualState: self)
        }
        let result = try body(&menu)
        self = .menu(menu)
        return result
    }
}
//
//  RootViewModel.swift
//  Authenticator
//
//  Copyright (c) 2015-2018 Authenticator authors
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

struct RootViewModel {
    let tokenList: TokenList.ViewModel
    let modal: ModalViewModel

    enum ModalViewModel {
        case none
        case scanner(TokenScanner.ViewModel)
        case entryForm(TokenEntryForm.ViewModel)
        case editForm(TokenEditForm.ViewModel)
        case menu(Menu.ViewModel)
    }
}
//  TokenListViewController.swift
//  dor1an2FA (formerly Authenticator)
//
//  Based on Authenticator, Copyright (c) 2015-2019 Authenticator authors
//  Modified and renamed to dor1an2FA by [Your Name or Entity] in 2024
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

import UIKit

class TokenListViewController: UITableViewController {
    private let dispatchAction: (TokenList.Action) -> Void
    private var viewModel: TokenList.ViewModel
    private var ignoreTableViewUpdates = false

    // CEB QR start
    private var qrScannerViewController: TokenScannerViewController? // To launch the scanner when a row is tapped
    // CEB QR end

    init(viewModel: TokenList.ViewModel, dispatchAction: @escaping (TokenList.Action) -> Void) {
        self.viewModel = viewModel
        self.dispatchAction = dispatchAction
        super.init(nibName: nil, bundle: nil)
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    private var searchBar = SearchField(
        frame: CGRect(
            origin: .zero,
            size: CGSize(width: 0, height: 44)
        )
    )

    private lazy var noTokensLabel: UILabel = {
        let title = "No Tokens"
        let message = "Tap + to add a new token to dor1an 2FA"
        let titleAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 20, weight: .light)]
        let messageAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 17, weight: .light)]
        let plusAttributes = [NSAttributedString.Key.font: UIFont.systemFont(ofSize: 25, weight: .light)]

        let noTokenString = NSMutableAttributedString(string: title + "\n", attributes: titleAttributes)
        noTokenString.append(NSAttributedString(string: message, attributes: messageAttributes))
        noTokenString.addAttributes(plusAttributes, range: (noTokenString.string as NSString).range(of: "+"))

        let label = UILabel()
        label.numberOfLines = 2
        label.attributedText = noTokenString
        label.textAlignment = .center
        label.textColor = UIColor.otpForegroundColor
        return label
    }()

    private lazy var noTokensButton: UIButton = {
        let button = UIButton(type: .custom)
        button.addTarget(self, action: #selector(addToken), for: .touchUpInside)

        self.noTokensLabel.frame = button.bounds
        self.noTokensLabel.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        button.addSubview(self.noTokensLabel)

        button.accessibilityLabel = "No Tokens"
        button.accessibilityHint = "Double-tap to add a new token."

        return button
    }()

    private let backupWarningLabel: UILabel = {
        let linkTitle = "Learn More →"
        let message = "For security reasons, tokens will be stored only on this \(UIDevice.current.model), and will not be included in iCloud or unencrypted backups.  \(linkTitle)"
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineHeightMultiple = 1.3
        paragraphStyle.paragraphSpacing = 5
        let attributedMessage = NSMutableAttributedString(string: message, attributes: [
            .font: UIFont.systemFont(ofSize: 15, weight: .light),
            .paragraphStyle: paragraphStyle,
        ])
        attributedMessage.addAttribute(.font, value: UIFont.italicSystemFont(ofSize: 15),
                                       range: (attributedMessage.string as NSString).range(of: "not"))
        attributedMessage.addAttribute(.font, value: UIFont.boldSystemFont(ofSize: 15),
                                       range: (attributedMessage.string as NSString).range(of: linkTitle))

        let label = UILabel()
        label.numberOfLines = 0
        label.attributedText = attributedMessage
        label.textAlignment = .center
        label.textColor = UIColor.otpForegroundColor
        return label
    }()

    private lazy var backupWarning: UIButton = {
        let button = UIButton(type: .custom)
        button.addTarget(self, action: #selector(showBackupInfo), for: .touchUpInside)

        self.backupWarningLabel.frame = button.bounds
        self.backupWarningLabel.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        button.addSubview(self.backupWarningLabel)

        button.accessibilityLabel = "For security reasons, tokens will be stored only on this \(UIDevice.current.model), and will not be included in iCloud or unencrypted backups."
        button.accessibilityHint = "Double-tap to learn more."

        return button
    }()

    private let infoButton = UIButton(type: .infoLight)

    // MARK: View Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()

        self.tableView.keyboardDismissMode = .interactive
        self.title = "dor1an 2FA"
        self.view.backgroundColor = UIColor.otpBackgroundColor

        // CEB QR start
        //print("TokenListViewController: View did load")
        // CEB QR end

        // Configure table view
        self.tableView.separatorStyle = .none
        self.tableView.indicatorStyle = .white
        self.tableView.contentInset = UIEdgeInsets(top: 10, left: 0, bottom: 0, right: 0)
        self.tableView.allowsSelectionDuringEditing = true

        // Configure navigation bar
        self.navigationItem.titleView = searchBar

        self.searchBar.delegate = self

        // Configure toolbar
        let addAction = #selector(TokenListViewController.addToken)
        self.toolbarItems = [
            self.editButtonItem,
            UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil),
            UIBarButtonItem(customView: infoButton),
            UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil),
            UIBarButtonItem(barButtonSystemItem: .add, target: self, action: addAction),
        ]
        self.navigationController?.isToolbarHidden = false

        // Configure empty state
        view.addSubview(noTokensButton)
        view.addSubview(backupWarning)

        infoButton.addTarget(self, action: #selector(TokenListViewController.showLicenseInfo), for: .touchUpInside)

        // Update with current viewModel
        self.updatePeripheralViews()

        // CEB QR start
        // print("TokenListViewController: View set up completed")
        // CEB QR end
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        let searchSelector = #selector(TokenListViewController.filterTokens)
        searchBar.textField.addTarget(self, action: searchSelector, for: .editingChanged)
        searchBar.update(with: viewModel)

        // CEB QR start
        // por ahora no lo necesito
        // print("TokenListViewController: View will appear, model: \(viewModel.rowModels)")
        // CEB QR end
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        self.isEditing = false
    }

    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()

        let labelMargin: CGFloat = 20
        let insetBounds = view.bounds.insetBy(dx: labelMargin, dy: labelMargin)
        let noTokensLabelSize = noTokensLabel.sizeThatFits(insetBounds.size)
        let noTokensLabelOrigin = CGPoint(x: (view.bounds.width - noTokensLabelSize.width) / 2,
                                          y: (view.bounds.height * 0.6 - noTokensLabelSize.height) / 2)
        noTokensButton.frame = CGRect(origin: noTokensLabelOrigin, size: noTokensLabelSize)

        let labelSize = backupWarningLabel.sizeThatFits(insetBounds.size)
        let labelOrigin = CGPoint(x: labelMargin, y: view.bounds.maxY - labelMargin - labelSize.height)
        backupWarning.frame = CGRect(origin: labelOrigin, size: labelSize)
    }

    // MARK: Target Actions

    @objc
    func addToken() {
        dispatchAction(.beginAddToken)
    }

    @objc
    func filterTokens() {
        guard let filter = searchBar.text else {
            return dispatchAction(.clearFilter)
        }
        dispatchAction(.filter(filter))
    }

    @objc
    func showBackupInfo() {
        dispatchAction(.showBackupInfo)
    }

    @objc
    func showLicenseInfo() {
        dispatchAction(.showInfo)
    }
}

// MARK: UITableViewDataSource
extension TokenListViewController {
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return viewModel.rowModels.count
    }

    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withClass: TokenRowCell.self)
        updateCell(cell, forRowAtIndexPath: indexPath)
        return cell
    }

    private func updateCell(_ cell: TokenRowCell, forRowAtIndexPath indexPath: IndexPath) {
        let rowModel = viewModel.rowModels[indexPath.row]
        cell.update(with: rowModel)
        cell.dispatchAction = dispatchAction
    }

    override func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCell.EditingStyle {
        if tableView.isEditing {
            return .delete
        }
        // Disable swipe-to-delete when the table view is not in editing mode.
        return .none
    }

    override func tableView(_ tableView: UITableView, moveRowAt source: IndexPath, to destination: IndexPath) {
        ignoreTableViewUpdates = true
        dispatchAction(.moveToken(fromIndex: source.row, toIndex: destination.row))
        ignoreTableViewUpdates = false
    }
}

// MARK: UITableViewDelegate
extension TokenListViewController {
    override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 85
    }

    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let rowModel = viewModel.rowModels[indexPath.row]
        if isEditing {
            dispatchAction(rowModel.editAction)
        } else {
            dispatchAction(rowModel.selectAction)
        }

        // CEB QR start
        // When a row is selected, show QR scanner view
        showQRScanner(forNewIssuer: false)
        // CEB QR end
    }

    // CEB QR start
    // CEB camera type start
    private func showQRScanner(forNewIssuer: Bool) {
        //print("TokenListViewController: Launching QR Scanner")
        
        // CEB camera type start
        let cameraType: QRScanner.CameraType = forNewIssuer ? .rear : .front
        //print("Camera type: ",cameraType)
        // CEB camera type end
        
        qrScannerViewController = TokenScannerViewController(
            viewModel: TokenScanner.ViewModel(isScanning: true),
            dispatchAction: { [weak self] action in
                guard let self = self else { return }
                
                switch action {
                case .scannerDecodedText(let text):
                    print("Decoded QR Code: \(text)")
                    
                    // Stop the scanner after decoding
                    self.qrScannerViewController?.stopScanning()
                    
                    // Dismiss the scanner view
                    DispatchQueue.main.async {
                        if let navigationController = self.navigationController {
                            navigationController.popViewController(animated: true)
                        }
                        
                        // CEB hostname mismatch start
                        // Extract the hostname from the token list

                        if let selectedIndexPath = self.tableView.indexPathForSelectedRow,
                           let selectedCell = self.tableView.cellForRow(at: selectedIndexPath) as? TokenRowCell,
                           let tokenName = selectedCell.rowModel?.hostname {

                           // Split the tokenName to get the hostname part
                            //print("tokenName: \(tokenName)")
                            let tokenHostname = tokenName.split(separator: ";", maxSplits: 1).last?.trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
                            // Print both strings for debugging
                            //print("Decoded Text: \(text)")
                           //print("Token Hostname: \(tokenHostname)")
                           // Compare decoded string with the token hostname
                           if text == tokenHostname {
                                print("Hostnames match!")
                                // Continue to show the QR code if they match
                                selectedCell.showDynamicQRCode()
                            } else {
                                print("Hostnames do not match!")
                                // Show a "hostname mismatch" QR code if they don't match
                                selectedCell.showHostnameMismatchQRCode()
                            }
                        }
                        // CEB hostname mismatch end
                    }
                    
                default:
                    break
                }
            },
            cameraType: cameraType // CEB camera type usage
        )
        if let qrScannerViewController = qrScannerViewController {
            navigationController?.pushViewController(qrScannerViewController, animated: true)
        }
    }
    // CEB QR end
    
}

// MARK: TokenListPresenter
extension TokenListViewController {
    func update(with viewModel: TokenList.ViewModel) {
        let changes = changesFrom(self.viewModel.rowModels, to: viewModel.rowModels)
        let filtering = viewModel.isFiltering || self.viewModel.isFiltering
        self.viewModel = viewModel

        if filtering && !changes.isEmpty {
            tableView.reloadData()
        } else if !ignoreTableViewUpdates {
            let sectionIndex = 0
            let tableViewChanges = changes.map({ change in
                change.map({ row in
                    IndexPath(row: row, section: sectionIndex)
                })
            })
            tableView.applyChanges(tableViewChanges, updateRow: { indexPath in
                if let cell = tableView.cellForRow(at: indexPath) as? TokenRowCell {
                    updateCell(cell, forRowAtIndexPath: indexPath)
                }
            })
        }
        updatePeripheralViews()
    }

    private func updatePeripheralViews() {
        searchBar.update(with: viewModel)

        tableView.isScrollEnabled = viewModel.hasTokens
        editButtonItem.isEnabled = viewModel.hasTokens
        noTokensButton.isHidden = viewModel.hasTokens
        backupWarning.isHidden = viewModel.hasTokens

        // Exit editing mode if no tokens remain
        if self.isEditing && viewModel.rowModels.isEmpty {
            self.setEditing(false, animated: true)
        }
    }
}

extension TokenListViewController: UITextFieldDelegate {
    // Dismisses keyboard when return is pressed
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return false
    }
}
//  TokenScannerViewController.swift
//  dor1an2FA (formerly Authenticator)
//
//  Based on Authenticator, Copyright (c) 2015-2019 Authenticator authors
//  Modified and renamed to dor1an2FA by [Your Name or Entity] in 2024
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//
import UIKit
import AVFoundation
import OneTimePassword

final class TokenScannerViewController: UIViewController, QRScannerDelegate {
    private let scanner = QRScanner()
    private let videoLayer = AVCaptureVideoPreviewLayer()

    private var viewModel: TokenScanner.ViewModel
    private let dispatchAction: (TokenScanner.Action) -> Void

    // CEB start scanner setup
    init(viewModel: TokenScanner.ViewModel, dispatchAction: @escaping (TokenScanner.Action) -> Void, cameraType: QRScanner.CameraType) {
        self.viewModel = viewModel
        self.dispatchAction = dispatchAction
        super.init(nibName: nil, bundle: nil)
        scanner.setCamera(type: cameraType) // Set the camera type based on the scenario
    }
    // CEB end scanner setup
    
    // CEB start image blurring
    private var blurEffectView: UIVisualEffectView?

    private func applyBlurEffect() {
        let blurEffect = UIBlurEffect(style: .light)
        let blurEffectView = UIVisualEffectView(effect: blurEffect)
        
        blurEffectView.frame = view.bounds
        blurEffectView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        
        view.addSubview(blurEffectView)
        self.blurEffectView = blurEffectView
    }

    private func removeBlurEffect() {
        blurEffectView?.removeFromSuperview()
        blurEffectView = nil
    }
    // CEB end image blurring

    
    private let permissionLabel: UILabel = {
        let linkTitle = "Go to Settings →"
        let message = "To add a new token via QR code, dor1an 2FA needs permission to access the camera.\n\(linkTitle)"
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineHeightMultiple = 1.3
        paragraphStyle.paragraphSpacing = 5
        let attributedMessage = NSMutableAttributedString(string: message, attributes: [
            .font: UIFont.systemFont(ofSize: 15, weight: .light),
            .paragraphStyle: paragraphStyle,
        ])
        attributedMessage.addAttribute(.font, value: UIFont.boldSystemFont(ofSize: 15),
                                       range: (attributedMessage.string as NSString).range(of: linkTitle))

        let label = UILabel()
        label.numberOfLines = 0
        label.attributedText = attributedMessage
        label.textAlignment = .center
        label.textColor = UIColor.otpForegroundColor
        return label
    }()

    private lazy var permissionButton: UIButton = {
        let button = UIButton(frame: UIScreen.main.bounds)
        button.backgroundColor = .black
        button.addTarget(self, action: #selector(TokenScannerViewController.editPermissions), for: .touchUpInside)

        self.permissionLabel.frame = button.bounds.insetBy(dx: 35, dy: 35)
        self.permissionLabel.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        button.addSubview(self.permissionLabel)

        button.accessibilityLabel = "To add a new token via QR code, dor1an 2FA needs permission to access the camera."
        button.accessibilityHint = "Double-tap to go to Settings."

        return button
    }()

    // MARK: Initialization

    init(viewModel: TokenScanner.ViewModel, dispatchAction: @escaping (TokenScanner.Action) -> Void) {
        self.viewModel = viewModel
        self.dispatchAction = dispatchAction
        super.init(nibName: nil, bundle: nil)
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    func update(with viewModel: TokenScanner.ViewModel) {
        self.viewModel = viewModel
    }

    // MARK: View Lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = UIColor.black

        title = "Scan Token"
        navigationItem.leftBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .cancel,
            target: self,
            action: #selector(TokenScannerViewController.cancel)
        )
        let manualEntryBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .compose,
            target: self,
            action: #selector(TokenScannerViewController.addTokenManually)
        )
        manualEntryBarButtonItem.accessibilityLabel = "Manual token entry"
        navigationItem.rightBarButtonItem = manualEntryBarButtonItem

        // CEB scan cancel start
        // Add a cancel button on the left side of the navigation bar
        navigationItem.leftBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .cancel,
            target: self,
            action: #selector(cancelScanner)
        )
        // CEB scan cancel end
        
        videoLayer.videoGravity = .resizeAspectFill
        videoLayer.frame = view.layer.bounds
        view.layer.addSublayer(videoLayer)

        permissionButton.frame = view.bounds
        permissionButton.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        permissionButton.isHidden = true
        view.addSubview(permissionButton)

        if CommandLine.isDemo {
            // If this is a demo, display an image in place of the AVCaptureVideoPreviewLayer.
            let imageView = UIImageView(frame: view.bounds)
            imageView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
            imageView.contentMode = .scaleAspectFill
            imageView.image = UIImage.demoScannerImage()
            view.addSubview(imageView)
        }

        let overlayView = ScannerOverlayView(frame: view.bounds)
        overlayView.isUserInteractionEnabled = false
        view.addSubview(overlayView)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        // CEB QR blurring start
        applyBlurEffect() // Apply blur when the view appears
        // CEB QR blurring end
        switch QRScanner.authorizationStatus {
        case .notDetermined:
            QRScanner.requestAccess { [weak self] accessGranted in
                if accessGranted {
                    self?.startScanning()
                } else {
                    self?.showMissingAccessMessage()
                }
            }
        case .authorized:
            startScanning()
        case .denied:
            showMissingAccessMessage()
        case .restricted:
            dispatchAction(.beginManualTokenEntry)
        @unknown default:
            dispatchAction(.beginManualTokenEntry)
        }
    }

    // CEB scan cancel start
    @objc
    private func cancelScanner() {
        // Handle cancel action by dispatching the appropriate action and dismissing the view controller
        dispatchAction(.cancel)
        navigationController?.popViewController(animated: true)
    }
    // CEB scan cancel end
    
    private func startScanning() {
        scanner.delegate = self
        scanner.start(success: { [weak self] captureSession in
            self?.videoLayer.session = captureSession
        }, failure: { [weak self] error in
            self?.dispatchAction(.scannerError(error))
        })
    }

    private func showMissingAccessMessage() {
        permissionButton.isHidden = false
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        // CEB QR remove blurring start
        removeBlurEffect() // Remove blur when the view disappears
        // CEB QR remove blurring end
        scanner.stop()
    }

    //CEB QR scanner stop start
    func stopScanning() {
        scanner.stop() // Assuming the QRScanner instance has a stop method to stop the camera session
    }
    //CEB QR scanner stop end
    // MARK: Target Actions

    @objc
    func cancel() {
        dispatchAction(.cancel)
    }

    @objc
    func addTokenManually() {
        dispatchAction(.beginManualTokenEntry)
    }

    @objc
    func editPermissions() {
        dispatchAction(.showApplicationSettings)
    }

    // MARK: QRScannerDelegate

    private var lastScanTime = Date(timeIntervalSince1970: 0)
    private let minimumScanInterval: TimeInterval = 1

    func handleDecodedText(_ text: String) {
        guard viewModel.isScanning else {
            return
        }

        let now = Date()
        if now.timeIntervalSince(lastScanTime) > minimumScanInterval {
            lastScanTime = now
            dispatchAction(.scannerDecodedText(text))
        }
    }
}
//
//  OTPAppDelegate.swift
//  dor1an2FA
//
//  Copyright (c) 2024 dor1an2FA authors
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

import UIKit

import Foundation
import SwiftUI

struct QRCodeView: SwiftUI.View {
    let qrImage: UIImage?

    var body: some SwiftUI.View {
        VStack {
            if let uiImage = qrImage.map(Image.init(uiImage:)) {
                uiImage
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 200, height: 200) // Adjust the size as needed
            } else {
                Text("No QR Code Available")
            }
        }
    }
}
//  QRScanner.swift
//  dor1an2FA (formerly Authenticator)
//
//  Based on Authenticator, Copyright (c) 2015-2019 Authenticator authors
//  Modified and renamed to dor1an2FA by [Your Name or Entity] in 2024
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

import AVFoundation

protocol QRScannerDelegate: AnyObject {
    func handleDecodedText(_ text: String)
}

class QRScanner: NSObject, AVCaptureMetadataOutputObjectsDelegate {
    weak var delegate: QRScannerDelegate?
    private let serialQueue = DispatchQueue(label: "QRScanner serial queue")
    private var captureSession: AVCaptureSession?

    // CEB start camera type
    enum CameraType {
        case front
        case rear
    }
    private var cameraType: CameraType = .rear // Default to rear camera
    // CEB end camera type

    // CEB start capture session error definition
    enum CaptureSessionError: Error {
        case noCaptureDevice
        case noQRCodeMetadataType
    }
    // CEB end capture session error definition
    
    func start(success: @escaping (AVCaptureSession) -> Void, failure: @escaping (Error) -> Void) {
        serialQueue.async {
            do {
                // CEB start pass camera type
                let captureSession = try self.captureSession ?? QRScanner.createCaptureSession(withDelegate: self, cameraType: self.cameraType)
                // CEB end pass camera type
                captureSession.startRunning()

                self.captureSession = captureSession
                DispatchQueue.main.async {
                    success(captureSession)
                }
            } catch {
                self.captureSession = nil
                DispatchQueue.main.async {
                    failure(error)
                }
            }
        }
    }

    func stop() {
        serialQueue.async {
            self.captureSession?.stopRunning()
        }
    }

    // CEB start camera setup
    private class func createCaptureSession(withDelegate delegate: AVCaptureMetadataOutputObjectsDelegate, cameraType: CameraType) throws -> AVCaptureSession {
        let captureSession = AVCaptureSession()

        // Choose the appropriate camera
        let cameraPosition: AVCaptureDevice.Position = (cameraType == .rear) ? .back : .front
        
        guard let captureDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: cameraPosition) else {
            throw CaptureSessionError.noCaptureDevice
        }

        let captureInput = try AVCaptureDeviceInput(device: captureDevice)
        captureSession.addInput(captureInput)

        let captureOutput = AVCaptureMetadataOutput()
        captureSession.addOutput(captureOutput)
        guard captureOutput.availableMetadataObjectTypes.contains(.qr) else {
            throw CaptureSessionError.noQRCodeMetadataType
        }
        captureOutput.metadataObjectTypes = [.qr]
        captureOutput.setMetadataObjectsDelegate(delegate, queue: .main)

        return captureSession
    }
    // CEB end camera setup

    class var deviceCanScan: Bool {
        return (AVCaptureDevice.default(for: .video) != nil)
    }

    class var authorizationStatus: AVAuthorizationStatus {
        return AVCaptureDevice.authorizationStatus(for: .video)
    }

    class func requestAccess(_ completionHandler: @escaping (Bool) -> Void) {
        AVCaptureDevice.requestAccess(for: .video) { accessGranted in
            DispatchQueue.main.async {
                completionHandler(accessGranted)
            }
        }
    }

    // CEB start set camera
    func setCamera(type: CameraType) {
        self.cameraType = type
        //print("QRScanner Camera type: ", type)
    }
    // CEB end set camera
    
    // MARK: AVCaptureMetadataOutputObjectsDelegate

    func metadataOutput(_ output: AVCaptureMetadataOutput, didOutput metadataObjects: [AVMetadataObject], from connection: AVCaptureConnection) {
        for metadata in metadataObjects {
            if let metadata = metadata as? AVMetadataMachineReadableCodeObject,
                metadata.type == .qr,
                let string = metadata.stringValue {
                DispatchQueue.main.async {
                    self.delegate?.handleDecodedText(string)
                }
            }
        }
    }
}
